'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _solidityParser = require('solidity-parser');

var solparser = _interopRequireWildcard(_solidityParser);

var _graphlib = require('graphlib');

var _graphlibDot = require('graphlib-dot');

var dot = _interopRequireWildcard(_graphlibDot);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var SEND_NODE_NAME = 'UNTRUSTED';
var SEND_NODE_STYLE = { shape: 'rectangle' };

var COLORS = {
  SEND: 'red',
  CONSTANT: 'blue',
  CALL: 'orange',
  INTERNAL: 'gray'
};

var prop = function prop(name) {
  return function (object) {
    return object[name];
  };
};
var propEquals = function propEquals(name, value) {
  return function (object) {
    return object[name] === value;
  };
};
var wrap = function wrap(val) {
  return Array.isArray(val) ? val : [val];
};

/** Converts an AST to array. */
var flatten = function flatten(ast) {
  var _ref;

  var children = wrap(ast.body || ast.expression || ast.left || ast.right || ast.literal || []);
  return (_ref = [ast]).concat.apply(_ref, _toConsumableArray(children.map(flatten)));
};

/** Finds all call expression nodes in an AST. */
var callees = function callees(ast) {
  return flatten(ast).filter(function (node) {
    return node.type === 'CallExpression';
  });
};

/** Determines the name of the graph node to render from the AST node. */
var graphNodeName = function graphNodeName(name) {
  return name === 'send' ? SEND_NODE_NAME : name;
};

exports.default = function (source) {

  // parse the Solidity source
  var ast = solparser.parse(source);
  //   try {
  //     ast = solparser.parse(source)
  //   } catch (e) {
  //     console.error('Parse error')
  //     console.error(e)
  //     process.exit(1)
  //   }

  // get a list of all function nodes
  var functionNodes = flatten(ast).filter(propEquals('type', 'FunctionDeclaration'));

  // analyze the security of the functions
  var analyzedNodes = functionNodes.map(function (node) {
    var functionCallees = callees(node).map(function (node) {
      return node.callee;
    });
    return {
      name: graphNodeName(node.name),
      callees: functionCallees,
      send: functionCallees.some(function (callee) {
        return (callee.name || callee.property && callee.property.name) === 'send';
      }),
      constant: node.modifiers && node.modifiers.some(propEquals('name', 'constant')),
      internal: node.modifiers && node.modifiers.some(propEquals('name', 'internal'))
    };
  });

  // console.log(JSON.stringify(ast, null, 2))
  // console.log(JSON.stringify(analyzedNodes, null, 2))

  // generate a graph
  var digraph = new _graphlib.Graph();
  analyzedNodes.forEach(function (_ref2) {
    var name = _ref2.name,
        callees = _ref2.callees,
        send = _ref2.send,
        constant = _ref2.constant,
        internal = _ref2.internal;


    // node
    digraph.setNode(graphNodeName(name), send ? { color: COLORS.SEND } : constant ? { color: COLORS.CONSTANT } : internal ? { color: COLORS.INTERNAL } : {});

    // edge
    callees.forEach(function (callee) {
      var calleeName = callee.property && callee.property.name || callee.name;
      digraph.setEdge(name, graphNodeName(calleeName));
    });
  });

  // add send node
  if (analyzedNodes.some(prop('send'))) {
    digraph.setNode(SEND_NODE_NAME, SEND_NODE_STYLE);
  }

  return dot.write(digraph);
};